#version 460

#extension GL_EXT_ray_tracing : require
#extension GL_EXT_shader_explicit_arithmetic_types_int64 : require
#extension GL_EXT_scalar_block_layout : enable
#extension GL_GOOGLE_include_directive : require

#include "globals.glsl"

layout(set = MODEL_SET, binding = SPHERE_BINDING, scalar) buffer _SphereInfo { Sphere spheres[]; };

hitAttributeEXT vec2 hitAttributes;

float intersectSphere(in const Sphere s, in const vec3 origin, in const vec3 direction, out bool inside)
{
    vec3  d = origin - s.center;
    float a = dot(direction, direction);
    float b = 2.0 * dot(d, direction);
    float c = dot(d, d) - s.radius * s.radius;
    float discriminant = b * b - 4.0 * a * c;
    inside = false;
    if(discriminant < 0)
    {
        return -1.0;
    }
    else if (discriminant == 0)
    {
        return -0.5 * b / a;
    }
    else
    {
        float q = (b > 0) ? -0.5 * (b + sqrt(discriminant)) : -0.5 * (b - sqrt(discriminant));
        float t0 = q / a;
        float t1 = c / q;
        float t = min(t0, t1);
        if(t > 0)
        {
            return t;
        }
        inside = t0 >= 0 && t1 <= 0 || t0 <= 0 && t1 >= 0;
        return max(t0, t1);
    }
}

void main()
{
    Sphere sphere = spheres[gl_PrimitiveID];

    float hitT    = -1.0;
    uint   hitKind = hitKindProceduralSphere; // FIXME: Always that atm.
    bool inside = false;

    hitT = intersectSphere(sphere, gl_WorldRayOriginEXT, gl_WorldRayDirectionEXT, inside);
    if(hitT >= 0.0)
    {
        hitAttributes = inside ? vec2(-1.0) : vec2(1.0);
        reportIntersectionEXT(hitT, hitKind);
    }
}