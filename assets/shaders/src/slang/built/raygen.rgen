#version 460
#extension GL_EXT_ray_tracing : require
#extension GL_EXT_nonuniform_qualifier : require
layout(row_major) uniform;
layout(row_major) buffer;

#line 63 0
struct PushConstants_0
{
    int frame_0;
    int lightCount_0;
};

layout(push_constant)
layout(std140) uniform _S1
{
    int frame_0;
    int lightCount_0;
}gPushConstants_0;

#line 8
layout(rgba32f)
layout(binding = 1, set = 2)
uniform image2D gAccumulationImage_0;


#line 17
struct CameraBufferRT_0
{
    mat4x4 inverseView_0;
    mat4x4 inverseProjection_0;
};


layout(binding = 0, set = 3)
layout(std140) uniform _S2
{
    mat4x4 inverseView_0;
    mat4x4 inverseProjection_0;
}gCamera_0;

#line 4
layout(binding = 0, set = 2)
uniform accelerationStructureEXT gTLAS_0;


#line 96 1
struct InstanceData_0
{
    int objectIndex_0;
    uint materialId_0;
    int lightId_0;
    int sphereId_0;
};


#line 40 0
layout(std430, binding = 1, set = 4) readonly buffer StructuredBuffer_InstanceData_t_0 {
    InstanceData_0 _data[];
} gInstanceData_0;

#line 39 1
struct Vertex_0
{
    vec3 position_0;
    vec3 normal_0;
    vec2 uv_0;
};


#line 57 0
layout(std430, binding = 0) readonly buffer StructuredBuffer_Vertex_t_0 {
    Vertex_0 _data[];
} gVertices_0[];
layout(std430, binding = 0, set = 1) readonly buffer StructuredBuffer_uint_t_0 {
    uint _data[];
} gIndices_0[];

#line 164 1
struct Material_0
{
    vec3 diffuseReflectance_0;
    int diffuseReflectanceTexture_0;
    uint twoSided_0;
    uint bxdfType_0;
    float interiorIor_0;
    float exteriorIor_0;
    vec3 specularReflectance_0;
    int specularReflectanceTexture_0;
    vec3 specularTransmittance_0;
    int specularTransmittanceTexture_0;
    vec2 alpha_0;
    int alphaTexture_0;
    int complexIorTexture_0;
    vec2 complexIor_0;
    uint nonlinear_0;
    uint canUseUv_0;
};


#line 44 0
layout(std430, binding = 2, set = 4) readonly buffer StructuredBuffer_Material_t_0 {
    Material_0 _data[];
} gMaterials_0;

#line 90 1
struct Sphere_0
{
    vec3 center_0;
    float radius_0;
};


#line 52 0
layout(std430, binding = 4, set = 4) readonly buffer StructuredBuffer_Sphere_t_0 {
    Sphere_0 _data[];
} gSpheres_0;

#line 12
layout(rgba32f)
layout(binding = 2, set = 2)
uniform image2D gResultImage_0;


#line 42 2
struct Hit_0
{
    uint hitKind_0;
    uint primitiveId_0;
    uint instanceCustomIndex_0;
    vec2 hitAttributes_0;
    mat4x3 worldToObject_0;
    mat4x3 objectToWorld_0;
};

struct RayPayload_0
{
    bool hit_0;
    vec3 hitPoint_0;
    Hit_0 hitInfo_0;
};


#line 7333 3
layout(location = 0)
rayPayloadEXT
RayPayload_0 p_0;


#line 3 4
uvec4 state_0;

void Random_init_0(uvec4 seed_0)
{
    state_0 = seed_0;
    return;
}

uvec4 Random_pcg4d_0()
{
    uvec4 _S3 = state_0 * 1664525U + 1013904223U;

#line 13
    state_0 = _S3;

    state_0[0] = _S3.x + _S3.y * _S3.w;
    state_0[1] = state_0.y + state_0.z * state_0.x;
    state_0[2] = state_0.z + state_0.x * state_0.y;
    state_0[3] = state_0.w + state_0.y * state_0.z;

    uvec4 _S4 = state_0 ^ state_0 >> 16U;

#line 20
    state_0 = _S4;

    state_0[0] = _S4.x + _S4.y * _S4.w;
    state_0[1] = state_0.y + state_0.z * state_0.x;
    state_0[2] = state_0.z + state_0.x * state_0.y;
    state_0[3] = state_0.w + state_0.y * state_0.z;

    return state_0;
}


#line 51
vec2 Random_rand2_0()
{
    uvec4 rInt_0 = Random_pcg4d_0();
    state_0[3] = state_0.w + 1U;
    return vec2(uintBitsToFloat(rInt_0.x >> 9 | 1065353216U) - 1.0, uintBitsToFloat(rInt_0.y >> 9 | 1065353216U) - 1.0);
}


#line 66 5
struct Ray_0
{
    vec4 origin_0;
    vec4 direction_0;
};

Ray_0 createRay_0(vec2 screenUV_0)
{
    Ray_0 ray_0;
    ray_0.origin_0 = (((vec4(0.0, 0.0, 0.0, 1.0)) * (gCamera_0.inverseView_0)));

    ray_0.direction_0 = normalize((((vec4(normalize((((vec4(screenUV_0.x, screenUV_0.y, 1.0, 1.0)) * (gCamera_0.inverseProjection_0))).xyz), 0.0)) * (gCamera_0.inverseView_0))));

    return ray_0;
}


#line 7194 3
struct RayDesc_0
{
    vec3 Origin_0;
    float TMin_0;
    vec3 Direction_0;
    float TMax_0;
};


#line 7283
void TraceRay_0(accelerationStructureEXT AccelerationStructure_0, uint RayFlags_0, uint InstanceInclusionMask_0, uint RayContributionToHitGroupIndex_0, uint MultiplierForGeometryContributionToHitGroupIndex_0, uint MissShaderIndex_0, RayDesc_0 Ray_1, inout RayPayload_0 Payload_0)
{

#line 7335
    p_0 = Payload_0;
    traceRayEXT(AccelerationStructure_0, RayFlags_0, InstanceInclusionMask_0, RayContributionToHitGroupIndex_0, MultiplierForGeometryContributionToHitGroupIndex_0, MissShaderIndex_0, Ray_1.Origin_0, Ray_1.TMin_0, Ray_1.Direction_0, Ray_1.TMax_0, (0));

#line 7348
    Payload_0 = p_0;
    return;
}


#line 11 2
struct DeviceTriangle_0
{
    Vertex_0  vertices_0[3];
    vec3 barycentrics_0;
    vec2 interpolatedUV_0;
    vec3 geometryNormal_0;
    vec3 interpolatedNormal_0;
    vec3 dfd1_0;
    vec3 dfd2_0;
    vec2 uvd1_0;
    vec2 uvd2_0;
    uint materialId_1;
    int lightId_1;
};


#line 8 5
DeviceTriangle_0 getTriangle_0(uint primitiveIndex_0, uint instanceCustomIndex_1, vec2 hitAttributes_1, mat4x3 worldToObject_1, vec3 viewPosition_0, vec3 hitPosition_0)
{



    uint objIdx_0 = uint(nonuniformEXT(gInstanceData_0._data[instanceCustomIndex_1].objectIndex_0));

#line 10
    DeviceTriangle_0 tri_0;

#line 23
    float _S5 = hitAttributes_1.x;

#line 23
    float _S6 = hitAttributes_1.y;

#line 23
    float _S7 = 1.0 - _S5 - _S6;

#line 23
    vec3 _S8 = vec3(_S7, _S5, _S6);

#line 23
    uint i_0 = 0U;

#line 23
    for(;;)
    {

#line 20
        tri_0.vertices_0[i_0] = gVertices_0[objIdx_0]._data[gIndices_0[objIdx_0]._data[3U]];

#line 17
        uint i_1 = i_0 + 1U;

#line 17
        if(i_1 < 3U)
        {
        }
        else
        {

#line 17
            break;
        }

#line 17
        i_0 = i_1;

#line 17
    }

#line 23
    tri_0.barycentrics_0 = _S8;
    tri_0.interpolatedUV_0 = tri_0.vertices_0[0].uv_0 * _S7 + tri_0.vertices_0[1].uv_0 * _S5 + tri_0.vertices_0[2].uv_0 * _S6;


    tri_0.interpolatedNormal_0 = normalize((((tri_0.vertices_0[0].normal_0 * tri_0.barycentrics_0.x + tri_0.vertices_0[1].normal_0 * tri_0.barycentrics_0.y + tri_0.vertices_0[2].normal_0 * tri_0.barycentrics_0.z) * (worldToObject_1))).xyz);

    tri_0.dfd1_0 = tri_0.vertices_0[1].position_0 - tri_0.vertices_0[0].position_0;
    tri_0.dfd2_0 = tri_0.vertices_0[2].position_0 - tri_0.vertices_0[0].position_0;

    tri_0.uvd1_0 = tri_0.vertices_0[1].uv_0 - tri_0.vertices_0[0].uv_0;
    tri_0.uvd2_0 = tri_0.vertices_0[2].uv_0 - tri_0.vertices_0[0].uv_0;

#line 40
    tri_0.geometryNormal_0 = normalize((((vec3(tri_0.dfd1_0.y * tri_0.dfd2_0.z - tri_0.dfd1_0.z * tri_0.dfd2_0.y, tri_0.dfd1_0.z * tri_0.dfd2_0.x - tri_0.dfd1_0.x * tri_0.dfd2_0.z, tri_0.dfd1_0.x * tri_0.dfd2_0.y - tri_0.dfd1_0.y * tri_0.dfd2_0.x)) * (worldToObject_1))).xyz);

    tri_0.materialId_1 = gInstanceData_0._data[instanceCustomIndex_1].materialId_0;

    tri_0.lightId_1 = gInstanceData_0._data[instanceCustomIndex_1].lightId_0;

    return tri_0;
}


#line 40 6
struct CoordinateSpace_0
{
    vec3 normal_1;
    vec3 tangent_0;
    vec3 bitangent_0;
};


#line 42
CoordinateSpace_0 CoordinateSpace_x24init_0(vec3 normal_2, bool hasUV_0, vec3 dfd1_1, vec3 dfd2_1, vec2 uvd1_1, vec2 uvd2_1)
{

#line 42
    CoordinateSpace_0 _S9;

#line 47
    _S9.normal_1 = normal_2;
    float _S10 = uvd1_1.x;

#line 48
    if(hasUV_0 && _S10 > 0.0)
    {
        float _S11 = uvd2_1.y;

#line 50
        float _S12 = uvd1_1.y;

#line 50
        vec3 t_0 = (_S11 * dfd1_1 - _S12 * dfd2_1) / (_S10 * _S11 - uvd2_1.x * _S12);
        vec3 _S13 = normalize(t_0 - normal_2 * dot(normal_2, t_0));

#line 51
        _S9.tangent_0 = _S13;
        _S9.bitangent_0 = cross(normal_2, _S13);

#line 48
    }
    else
    {

#line 58
        float _S14 = normal_2.z;

#line 58
        float normalSign_0;

#line 58
        if(_S14 < 0.0)
        {

#line 58
            normalSign_0 = -1.0;

#line 58
        }
        else
        {

#line 58
            normalSign_0 = 1.0;

#line 58
        }
        float a_0 = -1.0 / (normalSign_0 + _S14);
        float _S15 = normal_2.x;

#line 60
        float _S16 = normal_2.y;

#line 60
        float b_0 = _S15 * _S16 * a_0;
        _S9.tangent_0 = vec3(1.0 + normalSign_0 * _S15 * _S15 * a_0, normalSign_0 * b_0, - normalSign_0 * _S15);
        _S9.bitangent_0 = vec3(b_0, normalSign_0 + _S16 * _S16 * a_0, - _S16);

#line 48
    }

#line 42
    return _S9;
}


#line 28 2
struct DeviceSphere_0
{
    vec3 normal_3;
    uint materialId_2;
    int lightId_2;
};


#line 49 5
DeviceSphere_0 getSphere_0(vec3 hitPoint_1, uint instanceCustomIndex_2, uint primitiveIndex_1, vec2 hitAttributes_2)
{


    uint _S17 = instanceCustomIndex_2 + primitiveIndex_1;

#line 51
    DeviceSphere_0 sphere_0;

#line 57
    sphere_0.normal_3 = normalize(hitPoint_1 - gSpheres_0._data[uint(gInstanceData_0._data[_S17].sphereId_0)].center_0);

    sphere_0.materialId_2 = gInstanceData_0._data[_S17].materialId_0;

    sphere_0.lightId_2 = gInstanceData_0._data[_S17].lightId_0;

    return sphere_0;
}


#line 59 2
struct BxDFSample_0
{
    vec3 reflectance_0;
    vec3 wi_0;
    float pdf_0;
    bool dirac_0;
};


#line 82 5
vec3 tracePaths_0(vec2 uv_1)
{

#line 91
    Ray_0 _S18 = createRay_0(uv_1);



    BxDFSample_0 bxdfSample_0;
    bxdfSample_0.pdf_0 = 1.0;
    bxdfSample_0.dirac_0 = true;
    CoordinateSpace_0 space_0;
    const vec3 _S19 = vec3(0.0);

#line 99
    space_0.normal_1 = _S19;

#line 104
    RayDesc_0 rayDescriptor_0;
    vec3 _S20 = _S18.origin_0.xyz;

#line 105
    rayDescriptor_0.Origin_0 = _S20 + _S19 * 0.00000099999999747524;
    rayDescriptor_0.Direction_0 = _S18.direction_0.xyz;
    rayDescriptor_0.TMin_0 = 0.00100000004749745131;
    rayDescriptor_0.TMax_0 = 1000.0;

#line 103
    RayPayload_0 payload_0;

#line 109
    TraceRay_0(gTLAS_0, 1U, 255U, 0U, 0U, 0U, rayDescriptor_0, payload_0);

#line 120
    if(payload_0.hit_0)
    {



        if(payload_0.hitInfo_0.hitKind_0 == 0U)
        {
            DeviceTriangle_0 triangle_0 = getTriangle_0(payload_0.hitInfo_0.primitiveId_0, payload_0.hitInfo_0.instanceCustomIndex_0, payload_0.hitInfo_0.hitAttributes_0, payload_0.hitInfo_0.worldToObject_0, _S20, payload_0.hitPoint_0);


            space_0 = CoordinateSpace_x24init_0(triangle_0.geometryNormal_0, gMaterials_0._data[triangle_0.materialId_1].canUseUv_0 == 1U, triangle_0.dfd1_0, triangle_0.dfd2_0, triangle_0.uvd1_0, triangle_0.uvd2_0);

#line 125
        }
        else
        {

#line 132
            if(payload_0.hitInfo_0.hitKind_0 == 1U)
            {

#line 44 6
                const vec2 _S21 = vec2(0.0);

#line 137 5
                space_0 = CoordinateSpace_x24init_0(getSphere_0(payload_0.hitPoint_0, payload_0.hitInfo_0.instanceCustomIndex_0, payload_0.hitInfo_0.primitiveId_0, payload_0.hitInfo_0.hitAttributes_0).normal_3, false, _S19, _S19, _S21, _S21);

#line 132
            }

#line 125
        }

#line 141
        return space_0.normal_1 * 0.5 + 0.5;
    }

#line 188
    const vec3 _S22 = vec3(0.01999999955296516418, 0.03999999910593032837, 0.07999999821186065674);

#line 193
    return _S22;
}


#line 4737 3
vec3 saturate_0(vec3 x_0)
{
    return clamp(x_0, vec3(0.0), vec3(1.0));
}


#line 113 6
vec3 toneMapACES_0(vec3 color_0)
{

#line 120
    return saturate_0(color_0 * (2.50999999046325683594 * color_0 + 0.02999999932944774628) / (color_0 * (2.43000006675720214844 * color_0 + 0.58999997377395629883) + 0.14000000059604644775));
}


#line 106
vec3 linearTosRGB_0(vec3 linear_0)
{
    return pow(linear_0.xyz, vec3(0.45454543828964233398));
}


#line 197 5
void main()
{
    uvec3 _S23 = ((gl_LaunchIDEXT));

#line 199
    ivec2 pixelIndex_0 = ivec2(_S23.xy);
    vec4 accumColor_0;

#line 200
    vec4 _S24;

#line 200
    if(gPushConstants_0.frame_0 > 0)
    {

#line 200
        vec4 _S25 = (imageLoad((gAccumulationImage_0), ivec2((uvec2(pixelIndex_0)))));

#line 200
        _S24 = _S25;

#line 200
    }
    else
    {

#line 200
        _S24 = vec4(0.0, 0.0, 0.0, 0.0);

#line 200
    }

#line 200
    accumColor_0 = _S24;
    accumColor_0.xyz = _S24.xyz * _S24.w;
    uvec3 _S26 = ((gl_LaunchIDEXT));

#line 202
    vec2 pixelCorner_0 = vec2(_S26.xy);


    uvec3 _S27 = ((gl_LaunchIDEXT));

#line 205
    Random_init_0(uvec4(_S27.xy, uint(gPushConstants_0.frame_0), 2907U));

    vec2 _S28 = Random_rand2_0();

#line 207
    vec2 _S29 = pixelCorner_0 + _S28;

#line 207
    uvec3 _S30 = ((gl_LaunchSizeEXT));


    vec3 _S31 = tracePaths_0(_S29 / vec2(_S30.xy) * 2.0 - 1.0);

    accumColor_0.xyz = accumColor_0.xyz + _S31;
    accumColor_0[3] = accumColor_0.w + 1.0;
    accumColor_0.xyz = accumColor_0.xyz / accumColor_0.w;

    uvec2 _S32 = uvec2(pixelIndex_0);

#line 216
    imageStore((gAccumulationImage_0), ivec2((_S32)), accumColor_0);

    imageStore((gResultImage_0), ivec2((_S32)), vec4(linearTosRGB_0(toneMapACES_0(accumColor_0.xyz)), 1.0));
    return;
}

