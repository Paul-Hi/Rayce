#version 460

#extension GL_EXT_ray_tracing : require
#extension GL_GOOGLE_include_directive : require
#extension GL_EXT_shader_explicit_arithmetic_types_int64 : require
#extension GL_EXT_scalar_block_layout : enable
#extension GL_EXT_nonuniform_qualifier : enable

#include "globals.glsl"
#include "utils.glsl"

layout(set = 0, binding = 0) uniform accelerationStructureEXT TLAS;
layout(set = 0, binding = 1, rgba32f) uniform image2D accumulationImage;
layout(set = 0, binding = 2, rgba8) uniform image2D resultImage;

layout(location = 0) rayPayloadEXT RayPayload pld;

layout(set = 1, binding = 0, scalar) uniform CameraBufferRT
{
    mat4 inverseView;
    mat4 inverseProjection;
} camera;

layout(set = 2, binding = 0) uniform sampler2D textures[];
layout(set = 2, binding = 2, scalar) buffer _MaterialInfo { Material materials[]; };

layout(push_constant) uniform PushConstants {
    int frame;
};

void createRay(in vec2 screenUV, out vec4 origin, out vec4 direction)
{
    origin = camera.inverseView * vec4(0.0, 0.0, 0.0, 1.0);
    vec4 target = camera.inverseProjection * vec4(screenUV.x, screenUV.y, 1.0, 1.0);
    direction = normalize(camera.inverseView * vec4(normalize(target.xyz), 0.0));
}
/*
vec3 shade(in const Material material, in vec3 rayDirection)
{
    vec3 color = material.baseColor.rgb;
    if (material.baseColorTextureId >= 0)
    {
        color *= texture(textures[nonuniformEXT(material.baseColorTextureId)], pld.triangle.interpolatedUV).rgb;
    }

    vec3 normal = pld.triangle.interpolatedNormal;
    if(material.normalTextureId >= 0)
    {
        vec3 tangent, bitangent;
        createTBN(pld.triangle.interpolatedNormal, true,
                    pld.triangle.dfd1, pld.triangle.dfd2,
                    pld.triangle.uvd1, pld.triangle.uvd2,
                    tangent, bitangent);

        mat3 tbn = mat3(tangent, bitangent, normal);
        normal = normalize(texture(textures[nonuniformEXT(material.normalTextureId)], pld.triangle.interpolatedUV).rgb * 2.0 - 1.0);
        normal = normalize(tbn * normal.rgb);
    }

    float metallic = material.metallicFactor;
    float roughness = material.roughnessFactor;
    if (material.metallicRoughnessTextureId >= 0)
    {
        metallic = texture(textures[nonuniformEXT(material.metallicRoughnessTextureId)], pld.triangle.interpolatedUV).g;
        roughness = texture(textures[nonuniformEXT(material.metallicRoughnessTextureId)], pld.triangle.interpolatedUV).b;
    }
    float alpha = (roughness * roughness);

#if 0
    color *= max(dot(pld.triangle.interpolatedNormal, -rayDirection), 0.2);
#endif

    color += material.emissiveStrength * material.emissiveColor;
    if (material.emissiveTextureId >= 0)
    {
        color += material.emissiveStrength * texture(textures[nonuniformEXT(material.emissiveTextureId)], pld.triangle.interpolatedUV).rgb;
    }

    return color;
}
*/
vec3 getNormal(in Material material, out vec3 tangent, out vec3 bitangent)
{
    vec3 normal = pld.triangle.interpolatedNormal;
    createTBN(pld.triangle.interpolatedNormal, material.hasUV,
                pld.triangle.dfd1, pld.triangle.dfd2,
                pld.triangle.uvd1, pld.triangle.uvd2,
                tangent, bitangent);

    if(material.normalTextureId >= 0)
    {
        mat3 tbn = mat3(tangent, bitangent, normal);
        normal = normalize(texture(textures[nonuniformEXT(material.normalTextureId)], pld.triangle.interpolatedUV).rgb * 2.0 - 1.0);
        normal = normalize(tbn * normal.rgb);
    }

    return normal;
}

vec3 randomCosineDirection()
{
    float u = rand();
    float v = rand();

    float phi = TWO_PI * u;
    float cosTheta = sqrt(1.0 - v);
    float sinTheta = sqrt(v);
    float x = cos(phi) * sinTheta;
    float y = sin(phi) * sinTheta;
    float z = cosTheta;

    return vec3(x, y, z);
}

vec3 lambertCos(in Material material, out vec3 origin, out vec3 direction)
{
    // lambertian brdf
    vec3 diffuse = material.baseColor.rgb;
    if (material.baseColorTextureId >= 0)
    {
        diffuse *= texture(textures[nonuniformEXT(material.baseColorTextureId)], pld.triangle.interpolatedUV).rgb;
    }

    vec3 tangent, bitangent;
    vec3 normal = getNormal(material, tangent, bitangent);

    origin = pld.hitPoint + normal * EPSILON;
    vec3 randomCosine = randomCosineDirection();
    direction = fma(vec3(randomCosine.x), tangent, fma(vec3(randomCosine.y), bitangent, randomCosine.z * normal));

    // 1.0 / pdf = 1 / randomCosine.z = PI / dot(direction, normal);
    // -> everything cancels out -> return diffuse / PI * dot(direction, normal) * PI / dot(direction, normal)
    return diffuse;
}

vec3 emission(in Material material)
{
    vec3 e = material.emissiveStrength * material.emissiveColor;
    if (material.emissiveTextureId >= 0)
    {
        e += material.emissiveStrength * texture(textures[nonuniformEXT(material.emissiveTextureId)], pld.triangle.interpolatedUV).rgb;
    }
    return e;
}

vec3 tracePaths(in vec2 uv)
{
    vec3 color = vec3(0.0);
    vec3 throughput = vec3(1.0);
    int maxDepth = 8;

    // create ray origin and direction from camera data.
    vec4 origin, direction;
    createRay(uv, origin, direction);

    for(uint depth = 0; depth < maxDepth; ++depth)
    {
        traceRayEXT(
            TLAS,
            gl_RayFlagsOpaqueEXT | gl_RayFlagsCullBackFacingTrianglesEXT,
            0xff,   // cullMask
            0,      // sbtRecordOffset
            0,      // sbtRecordStride
            0,      // missIndex
            origin.xyz,
            0.001,
            direction.xyz,
            1000.0,
            0       // payloadLocation
        );

        if(pld.hit)
        {
            Material material = materials[pld.triangle.materialId];

            color += throughput * emission(material);
            vec3 brdf = lambertCos(material, origin.xyz, direction.xyz);
            throughput *= brdf;
            continue;
        }

        break;
    }

    return color;
}

void main()
{
    vec4 accumColor = frame > 0 ? imageLoad(accumulationImage, ivec2(gl_LaunchIDEXT.xy)) : vec4(0.0, 0.0, 0.0, 0.0);
    accumColor.rgb *= accumColor.w;

    vec3 color = vec3(0.0);
    const vec2 pixelCorner = vec2(gl_LaunchIDEXT.xy);
    rngState = 1 + wangHash(gl_LaunchIDEXT.y * gl_LaunchSizeEXT.x + gl_LaunchIDEXT.x) + frame * 100;
    vec2 uv;

    uv = (pixelCorner + vec2(rand(), rand())) / vec2(gl_LaunchSizeEXT.xy);
    uv = uv * 2.0 - 1.0;

    color += tracePaths(uv);

    accumColor.rgb += color;
    accumColor.w += 1.0;
    accumColor.rgb /= accumColor.w;
    imageStore(accumulationImage, ivec2(gl_LaunchIDEXT.xy), accumColor);
    vec4 resultColor = vec4(linearTosRGB(toneMapACES(accumColor.rgb)), 1.0);
    imageStore(resultImage, ivec2(gl_LaunchIDEXT.xy), resultColor);
}
