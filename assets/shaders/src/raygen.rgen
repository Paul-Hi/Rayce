#version 460

#extension GL_EXT_ray_tracing : require
#extension GL_EXT_buffer_reference2 : require
#extension GL_GOOGLE_include_directive : require
#extension GL_EXT_shader_explicit_arithmetic_types_int64 : require
#extension GL_EXT_scalar_block_layout : enable
#extension GL_EXT_nonuniform_qualifier : enable

#include "globals.glsl"
#include "utils.glsl"

layout(set = RT_SET, binding = TLAS_BINDING) uniform accelerationStructureEXT TLAS;
layout(set = RT_SET, binding = ACCUM_BINDING, rgba32f) uniform image2D accumulationImage;
layout(set = RT_SET, binding = RESULT_BINDING, rgba8) uniform image2D resultImage;

layout(location = 0) rayPayloadEXT RayPayload pld;

layout(set = CAMERA_SET, binding = CAMERA_BINDING, scalar) uniform CameraBufferRT
{
    mat4 inverseView;
    mat4 inverseProjection;
} camera;

layout(set = MODEL_SET, binding = TEXTURE_BINDING) uniform sampler2D textures[];
layout(set = MODEL_SET, binding = INSTANCE_BINDING, scalar) buffer _InstanceInfo { InstanceData ref[]; };
layout(set = MODEL_SET, binding = MATERIAL_BINDING, scalar) buffer _MaterialInfo { Material materials[]; };
layout(set = MODEL_SET, binding = LIGHT_BINDING, scalar) buffer _LightInfo { Light lights[]; };
layout(set = MODEL_SET, binding = SPHERE_BINDING, scalar) buffer _SphereInfo { Sphere spheres[]; };

layout(buffer_reference, scalar) buffer Vertices { Vertex v[]; };
layout(buffer_reference, scalar) buffer Indices { uint i[]; };

layout(push_constant) uniform PushConstants {
    int frame;
    int lightCount;
};

#include "surface_state.glsl"
#include "bsdf.glsl"

Tri getTriangle(uint primitiveIndex, uint instanceCustomIndex, vec2 hitAttributes, mat4x3 worldToObject)
{
    Tri tri;
    const uint triangleIndex = primitiveIndex * 3;

    Indices indices = Indices(ref[instanceCustomIndex].indexReference);
    Vertices vertices = Vertices(ref[instanceCustomIndex].vertexReference);

    for(uint i = 0; i < 3; ++i)
    {
        const uint idx = indices.i[triangleIndex + i];
        tri.vertices[i] = vertices.v[idx];
    }

    tri.barycentrics = vec3(1.0 - hitAttributes.x - hitAttributes.y, hitAttributes.x, hitAttributes.y);
    tri.interpolatedUV = tri.vertices[0].uv * tri.barycentrics.x + tri.vertices[1].uv * tri.barycentrics.y + tri.vertices[2].uv * tri.barycentrics.z;

    tri.interpolatedNormal = normalize(tri.vertices[0].normal * tri.barycentrics.x + tri.vertices[1].normal * tri.barycentrics.y + tri.vertices[2].normal * tri.barycentrics.z);
    tri.interpolatedNormal = normalize(vec3(tri.interpolatedNormal * worldToObject));

    tri.dfd1 = tri.vertices[1].position - tri.vertices[0].position;
    tri.dfd2 = tri.vertices[2].position - tri.vertices[0].position;
    tri.uvd1 = tri.vertices[1].uv - tri.vertices[0].uv;
    tri.uvd2 = tri.vertices[2].uv - tri.vertices[0].uv;

    tri.geometryNormal = vec3(
        tri.dfd1.y * tri.dfd2.z - tri.dfd1.z * tri.dfd2.y,
        tri.dfd1.z * tri.dfd2.x - tri.dfd1.x * tri.dfd2.z,
        tri.dfd1.x * tri.dfd2.y - tri.dfd1.y * tri.dfd2.x
    );
    tri.geometryNormal = normalize(vec3(tri.geometryNormal * worldToObject));

    tri.materialId = ref[instanceCustomIndex].materialId;

    tri.lightId = ref[instanceCustomIndex].lightId;

    return tri;
}

bool sampleLights(in vec3 p, out LightSample lightSample)
{
    lightSample.pdf = 1.0 / float(lightCount);
    int lightIndex = int(rand() * lightCount);

    Light sampledLight = lights[lightIndex];
/*
    if(sampledLight.type == area)
    {
        Indices indices = Indices(ref[sampledLight.meshId].indexReference);
        Vertices vertices = Vertices(ref[sampledLight.meshId].vertexReference);

        // FIXME: In theory we would have to weight that ...
        uint triangleIndex = uint(rand() * sampledLight.triangleCount) * 3;
        lightSample.pdf *= 1.0 / float(sampledLight.triangleCount);

        Vertex vert[3];
        for(uint i = 0; i < 3; ++i)
        {
            const uint idx = indices.i[triangleIndex + i];
            vert[i] = vertices.v[idx];
        }

        vec2 rands = vec2(rand(), rand());
        float u = 1.0 - sqrt(rands.x);
        float v = rands.y * sqrt(rands.x);
        vec3 barycentrics = vec3(u, v, 1.0 - u - v);

        vec3 interpolatedPosition = vert[0].position * barycentrics.x + vert[1].position * barycentrics.y + vert[2].position * barycentrics.z;
        interpolatedPosition = vec3(sampledLight.objectToWorld * vec4(interpolatedPosition, 1.0));
        vec3 interpolatedNormal = normalize(vert[0].normal * barycentrics.x + vert[1].normal * barycentrics.y + vert[2].normal * barycentrics.z);
        interpolatedNormal = normalize(vec3(transpose(inverse(sampledLight.objectToWorld)) * vec4(interpolatedNormal, 0.0)));

        vec3 wDir = interpolatedPosition - p;
        float pointDistance = length(wDir);

        float G = dot(interpolatedNormal, -wDir);

        surfaceState.wi = worldToTangentFrame(normalize(wDir), surfaceState.tangent, surfaceState.bitangent, surfaceState.normal);
        float nDotL = cosTheta(surfaceState.wi);

        if(nDotL <= 0.0 || G <= 0.0)
        {
            return false;
        }

        pld.hit = true;
        traceRayEXT(
            TLAS,
            gl_RayFlagsSkipClosestHitShaderEXT | gl_RayFlagsTerminateOnFirstHitEXT | gl_RayFlagsOpaqueEXT | gl_RayFlagsCullBackFacingTrianglesEXT,
            0xff,   // cullMask
            0,      // sbtRecordOffset
            0,      // sbtRecordStride
            0,      // missIndex
            p,
            0.001,
            wDir,
            pointDistance,
            0       // payloadLocation
        );

        if(pld.hit)
        {
            return false;
        }

        const vec3 A = vec3(vert[1].position - vert[0].position);
        const vec3 B = vec3(vert[2].position - vert[0].position);
        lightSample.pdf *= 2.0 / (length((cross(A, B))));

        lightSample.radiance = nDotL * G * sampledLight.radiance;

        return true;
    }
*/
    return false;
};

void createRay(in vec2 screenUV, out vec4 origin, out vec4 direction)
{
    origin = camera.inverseView * vec4(0.0, 0.0, 0.0, 1.0);
    vec4 target = camera.inverseProjection * vec4(screenUV.x, screenUV.y, 1.0, 1.0);
    direction = normalize(camera.inverseView * vec4(normalize(target.xyz), 0.0));
}

vec3 tracePaths(in vec2 uv)
{
    vec3 color = vec3(0.0);
    vec3 throughput = vec3(1.0);
    const int maxDepth = 8;
    const int russianRouletteStart = 4;

    // create ray origin and direction from camera data.
    vec4 origin, direction;
    createRay(uv, origin, direction);

    for(uint depth = 0; depth < maxDepth; ++depth)
    {
        traceRayEXT(
            TLAS,
            gl_RayFlagsOpaqueEXT | gl_RayFlagsCullBackFacingTrianglesEXT,
            0xff,   // cullMask
            0,      // sbtRecordOffset
            0,      // sbtRecordStride
            0,      // missIndex
            origin.xyz,
            0.001,
            direction.xyz,
            1000.0,
            0       // payloadLocation
        );

        if(pld.hit)
        {
            uint lightId = -1;
            if(pld.hitInfo.hitKind == hitKindTriangleMesh)
            {
                Tri triangle = getTriangle(pld.hitInfo.primitiveId, pld.hitInfo.instanceCustomIndex, pld.hitInfo.hitAttributes, pld.hitInfo.worldToObject);
                Material material = materials[triangle.materialId];
                populateSurfaceStateTriangle(material, triangle);
            }

            surfaceState.wo = worldToTangentFrame(-direction.xyz, surfaceState.tangent, surfaceState.bitangent, surfaceState.normal);
            origin.xyz = pld.hitPoint;

            if(lightId >= 0)
            {
                color += throughput * lights[lightId].radiance;
            }

            // LightSample lightSample;
            // if(sampleLights(origin.xyz, lightSample))
            // {
            //     color += throughput * evaluateBSDF() * lightSample.radiance / lightSample.pdf;
            // }

            BSDFSample bsdfSample;
            if(!sampleBSDF(bsdfSample))
            {
                break;
            }

            direction.xyz = tangentToWorld(surfaceState.wi, surfaceState.tangent, surfaceState.bitangent, surfaceState.normal);

            float nDotL = cosTheta(surfaceState.wi);

            throughput *= bsdfSample.reflectance * nDotL / bsdfSample.pdf;

            // if(lightId < 0)
            // {
            //     throughput *= bsdfSample.reflectance * nDotL / bsdfSample.pdf;
            // }
            // else if (depth == 0)
            // {
            //     color += lights[lightId].radiance;
            // }

            // russian roulette
            if (depth >= russianRouletteStart)
            {
                float p = max(throughput.x, max(throughput.y, throughput.z));
                if (rand() > p) {
                    break;
                }

                throughput *= 1.0 / p;
            }
            continue;
        }
        else
        {
            color += throughput * vec3(0.02, 0.04, 0.08);
        }

        break;
    }

    return color;
}

void main()
{
    vec4 accumColor = frame > 0 ? imageLoad(accumulationImage, ivec2(gl_LaunchIDEXT.xy)) : vec4(0.0, 0.0, 0.0, 0.0);
    accumColor.rgb *= accumColor.w;

    vec3 color = vec3(0.0);
    const vec2 pixelCorner = vec2(gl_LaunchIDEXT.xy);
    rngState = 1 + wangHash(gl_LaunchIDEXT.y * gl_LaunchSizeEXT.x + gl_LaunchIDEXT.x) + frame * 100;
    vec2 uv;

    uv = (pixelCorner + vec2(rand(), rand())) / vec2(gl_LaunchSizeEXT.xy);
    uv = uv * 2.0 - 1.0;

    color += tracePaths(uv);

    accumColor.rgb += color;
    accumColor.w += 1.0;
    accumColor.rgb /= accumColor.w;
    imageStore(accumulationImage, ivec2(gl_LaunchIDEXT.xy), accumColor);
    vec4 resultColor = vec4(linearTosRGB(toneMapACES(accumColor.rgb)), 1.0);
    imageStore(resultImage, ivec2(gl_LaunchIDEXT.xy), resultColor);
}
